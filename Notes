Problems and their Solutions for the sake of my posterity

Problem: How to create a new line without using ''' '''?
Context: I ran into this issue with the inventory_list function when I wanted to add both a new line and the item
from the inventory dictionary to the output string.
Solution: '\n' generates a new line. I learned this because Pycharm reformatted my text in the help module replacing my
''' ''' with a bunch of '\n' You can append it to a line like "text\n"

Problem: How do I iterate over the items of a dictionary?
Context: I needed some way to add items from the inventory dictionary to the output string of the inventory_list
function without writing out code for every single item.
Solution: for item in inventory solved the issue

Problem: How do I direct the program to look for the value of the key-value pair in a dictionary and do something
(or not do something) based on that value?
Context: I needed to assess whether or not the item in the inventory dictionary was held by the player (true) or
not (false).
Solution: if inventory[item]: This is the right if statement. It is condensed, since I shouldn't ever have to write if
___ == True: inventory[item] selects the value of the item.

Problem: How do I update a dictionary if a value changes if that dictionary is in a different module?
Context: I need to update the inventory dictionary of the inventory_list function when a player gains or loses an item.
Defining the inventory within the function seems to be a problem, because it will default the values back to their
initial value and not take inputs from the program. I need to insert something after the initial dictionary that looks
for updates to that dictionary in main.py
Solution: Separating the dictionary from the rest of the function meant I didn't need to call the dictionary from
within it and that solved the issue. Inventory.inventory["hat"] = False was both correct syntax and updated the
dictionary, which, since the function did not have the dictionary inside it, was not returned to its initial state
by the function. Gotta keep 'em separated.

Problem: How do I enable moving back to an earlier location?
Context: When first working on locations, I was able to go from "beach" to "spit" but not the other way around.
The program just cut out.
Solution: Put everything in a while loop. However, there is quickly coming to be some repetitive code. I reduced this by
creating a separate global_functions module.

Problem: Importing global_functions module dramatically cleaned up code, but resulted in former else "mysterious"
statement now displaying for global functions
Context: see problem above.
Solution:         if Functions.globe.__contains__(userinput):
            Functions.global_functions(userinput)
I could have simply, made an if condition for all the terms in the global_functions function, but if I did that,
if I ever added new functions, I would have to add them to each of the conditions every time they appear. I wanted
something more dynamic. Making a dictionary of the functions partially solved the issue, because all I will have to
do in the future is add the function to the globe dictionary, and it will automatically be included in the input that
is checked for. However, accessing this dictionary seemed difficult.
The solution here was to use a magic method, __contains__ which does what I want -- checks the dictionary to see if the
thing in () {here, user input} -- is in the dictionary. I found it just by scrolling through the suggested list in
Pycharm.
I now have a little more code than what I just had after I cleaned up, but still way less than before. I also now have a
dynamic global functions list!

Problem: How do I stop this crazy thing?
Context: I want to test having an end to the program, however, I cannot seem to find a way to terminate it. I decided to
terminate the program ('win condition') when the player touches the statue, because aliens, of course. However, whether
I put break, or try to use a variable condition to end the while loop, the program does not terminate. I assume this has
something to do with the fact that it is happening with an indented condition.
Attempts: Not resolved by multiple "breaks."
Solution: Resolved by combining the previous strategies -- using a variable condition for the whole program's while
loop, changing the variable to meet that condition and then using "break."


Problem: How do I check all the values in a dictionary?
Context: __contains__ did all the keys, but I want to output an (empty) in my inventory if the value of all items is
false.
Attempts: elif not inventory.values did not work
def inventory_list():
    output = "You have the following items:"
    for item in inventory:
        if inventory[item]:
            output += '\n' + item
        else:
            output = "(empty)""

    return output

Did not work, however, it did leave an (empty) where the item used to be (and deleted the you have the following items)
and that might be useful for something later.
Solution:   elif True not in [*inventory.values()]:
                output = "(empty)"
Apparently, so sayeth the internet, the * operand, unpacks dictionaries and list. Using the .value method unpacks the
values of the dictionary and "True not in" is asking to check if there is a True value in that dictionary and does the
following if it is not. I figured out that part, once the internet explained the * operand to me.
UPDATE: after working on the anagram program, I realized I did the same thing there without the * and it worked. I
removed it here and it also worked. So I might have misunderstood exactly where and why it belongs somewhere. Perhaps
it would be if I were referencing both keys and values?

Problem: How can I associate multiple values with a single key in a dictionary?
Context: I may want to associate multiple things with a single location, for instance.
Attempts: The internet suggests this is possible, effectively by making the value a list
(https://pythonguides.com/python-dictionary-multiple-values/), but I don't quite understand how to use this
Others recommend "itemgetter" function, but I haven't figured out how to use this quite yet.
Solution: I can't seem to do this simply quite yet, but in the meantime, I was able to do what I needed to do(shorter
location descriptions) by using multiple dicts. See problem below.

Problem: Find a way to have a shorter description for returning to an area.
Context: It feels like, when returning to an area, you shouldn't have the full description two times. You should get
and abbreviated description.
Solution: I somehow managed this. I made a dictionary for short descriptions, and a third for vist count. Then, I
modified the location function with an elif to display the short description if visit count was higher than 1. Now,
what worked, and I am amazed it did, was that, e.g. using "beach" for all three dictionaries, when I set the
present_location variable to "beach", it seamlessly moved through all three dictionaries, just fine. The only other
thing I had to do was change the output for moving location from the set Location.location (pulling from dict),
and change it to the output of the location function...now that there is a difference.
As a bonus, I modified the location function in global functions to output the name of the present location and the
short description...well technically, the output of the location function but it seems to work correctly.

Problem: How do I predicate something on whether or not a user has taken an action?
Solution: Lots of ways, here I did the following:
    made a variable hidden_cave and set it to false
    Then made it change to true if the user had cleaned the socks

Problem: How to introduce an item that can be picked up and used, rather than just in the inventory from the beginning?
     if not Inventory.inventory.get("dirty_socks"):
                Inventory.inventory.update({"dirty_socks": True})
    .get requests the value in the dictionary (here, true or false)
    .update, if it uses a key which already exists (so it seems) changes the value for that key

    elif userinput == "clean socks" and Inventory.inventory.get("dirty_socks"):
            Inventory.inventory.update({"dirty_socks": False})
            does the reverse, essentially.

but
Problem (2): Having done this, the user can pick up an infinite amount of socks, creating a loop I don't want.
Solution: Instead of having only True or False values in the dictionary, I set the value equal to the integer 0, then
had 1 (basically) equal have the socks and 2 (basically) equal already have the socks and printed the correct message
accordingly. I just needed to add a third value: "already had" to the simple "have" or "not have."


Problem (3): But this creates problems with the inventory system, because it is now the case that there can be an
inventory with no true values but which still has items in it (dirty_socks set to 1): what do?
Solution:

def inventory_list():
    output = ""
    for item in inventory:
        if inventory[item]:
            output += '\n' + item
    for item in advanced_inventory:
        if advanced_inventory[item] == 1:
            output += '\n' + item
    if output == "":
        output += "(empty)"
    elif output != "":
        message = "You have the following items:"
        output = message + output

I made a new "advanced-Inventory" dictionary for items with 0, 1, or 2 (or more) as values. Then, I made a separate for
item... for both and added everything to the string. but..

Problem (4): This then lead to another problem, I couldn't use the script I had to report the inventory was empty!
Solution: As above, basically, I made it so that, after considering both lists, if there is nothing, make the string
(empty) If there is, though, append a message to the output string and make that the new output string. Apparently,
strings are immutable -- you cannot jsut put things into the strings, you have to concatenate something to the start
or end.

Problem: How do I dynamically have a "look around" (and "go") function that identifies where a player is and tells
them where they can go (and lets them go) to adjacent areas?
Solution: Conceptually, I think I can do this with cartesian coordinates
Step 1: Define a dictionary of coordinates for every location [x, y]
Step 2: Define a function to compare those coordinates to coordinates of present_location
Step 3: If an item in the coordinate dictionary is adjacent (orthogonal) to coordinates of present_location,
        output that item in a list. This was the hardest step. I needed the absolute value(distance) between the two
        coordinates to be 1 more in the x-value if the y-value stays the same, or the inverse, but not both.
Step 4: put it all together
    def look_around():
    present_location = Location.present_location
    cord3 = 0
    cord4 = 0
    output = "Around you, you see:"
    for item in dict1:
        if present_location == item:
            present_coordinates = dict1[item]
            cord3, cord4 = present_coordinates
    for item in dict1:
        list1 = dict1[item]
        cord1, cord2 = list1
        if ((abs(cord3 - cord1) == 0 and abs(cord4 - cord2) == 1) or
                (abs(cord3 - cord1) == 1 and abs(cord4 - cord2) == 0)):
            output += '\n' + item
        else:
            pass
    return output

In addition, although I mapped this out as an orthogonal grid (every place can go four places), if I simplified the
function -- if I returned it to what didn't work, in fact -- where it considered a distance of +- 1 for either x or y,
that would give me a full grid, right? with diagonals? allowing every place to go eight places?
[0, 0] [0,1] [1,0] [0, -1] [-1, 0] an add [1, -1] [-1, 1] [1, 1] [-1, -1]? Maybe I should remap the coordinates at some
point in the future, when I have enough maps to justify that (though that might make the flow through the game a bit
more convoluted and less constrained).

Problem: How do I tie in a go-to function to the look around function?
Solution: By not exactly doing that. I had the go to function take the basic structure of the look around function
but changed it just enough. It produces the same list, but doesn't output anything. That way I don't have to take
the output string of the look around function and try to reinterpret it for the go to function (which was what I
originally tried to do).
The bigger issue was actually the __contains__ magic because up until now, what is being queried is whether or not
the user's inputted string appears in the globe dictionary. If it does, then it runs that function, and doesn't
otherwise. But I can't put the entire location dictionary into it; the input here is variable. So what I did is add
the alternative condition to run that function if they input a location -- but if it isn't a location they can go to,
it still outputs "a mysterious force prevents this"
My code is now a lot cleaner, having exported all these global functions. This makes room for area specific functions!
I added a few area specific functions to celebrate.

Problem: How can I hide certain places before a condition is met?
Solution: I think the simplest solution would be to simply add them to the dictionary once that condition is met, and
not have it there by default, but how do I add all the text and whatnot?

To Do:


Practice some OOP with the locations.
I'd like some more dynamic input from the user to be accepted. Why can't a rock be tossed just as well as thrown? Can
I use OOP to solve this?



Completely unrelated things
Problem: I wasn't able to install a module using pip from the command line
Solution: Looks like the issue as that the project was using the 3.8 interpreter. Switching to the 3.10 interpreter in a
new project and installing it that way worked fine.

Problem: How do I use the xor function? It doesn't seem to be built in.
Solution: it isn't but can be imported from the Operator module

Problem: Referring to global functions within functions
Solution: I can seem to largely avoid this by defining a local variable or moving the global variable inside the
function. However, I can also use the global keyword, it seems. As I do here:
    def go_to(self):
        global present_location
        if present_location != self.name:
            present_location = self.name
        return present_location